#!/usr/bin/env python3

import os
import re
import time

import sys
import pandas as pd
import argparse



def filter_tsv_gidlist_using_qid_cov(input_tsv, output_tsv=None, qid_threshold=100., cov_threshold=100., return_gid_list=False):
    """
    Method to filter the tsv files generated by mmseqs and create a new filter tsv
    Args:
        input_tsv: Filename of the input tsv file
        output_tsv: Filename of the output tsv file
        qid_threshold: qid threshold expressed as %
        cov_threshold: cov threshold expressed as %

    Returns: Dump a filtered tsv file if requested, returns a filtered list of gid if requested

    """
    df = pd.read_csv(input_tsv, sep='\t')

    # This threshold value may be changed
    dfqid = df[df["pident"] > qid_threshold]
    dfqidcov = dfqid[dfqid["qcov"] > cov_threshold/100.]

    if output_tsv:
        dfqidcov.to_csv(output_tsv, sep='\t')

    if return_gid_list:
        list_filtered_gid = dfqidcov['target'].tolist()
        d_seen = {}
        list_filtered_gid_no_duplicates = []
        for x in list_filtered_gid:
            if x not in d_seen:
                list_filtered_gid_no_duplicates.append(x)
                d_seen[x] = True

        # If using this track, beware that in case a gid is present several times
        # with different %id and %cov it may then escape the filter
        # The alignment file is supposed to contain only one instance of every gid
        return list_filtered_gid_no_duplicates


def dump_ali_from_gid_list_keep_aliorder(input_ali, output_ali, list_gid, keep_first_sequence=True):
    """
    Method to dump an alignment file ordered and filtered following the gid provided in a list
    Args:
        input_ali: input alignment filename
        output_ali: output alignment filename
        list_gid: list of gid

    Returns: Dump an alignment file ordered as in the input gid list

    """
    seq = 0
    # In this method we don't use the list order but rather rely on the order of the input list
    # Another module can be used to reorder
    set_gid = set(list_gid)
    d_input_fasta_file = dict()
    with open(input_ali,'r') as fid_in:
        with open(output_ali,"w") as fid_out:
            for ii, ll in enumerate(fid_in):
                if ll[0] == ">":
                    line_index_header = ii
                    if keep_first_sequence and seq == 0:
                        fid_out.write(ll)
                        seq += 1
                        continue
                    gid = ll.split()[0][1:]
                    if gid in set_gid:
                        DO_keep_sequence = True
                        d_input_fasta_file[gid] = {}
                        d_input_fasta_file[gid]['header'] = ll
                        d_input_fasta_file[gid]['sequence'] = ""
                        seq += 1
                    else:
                        DO_keep_sequence = False
                elif len(ll) > 0:
                    # add this constraint to prevent that trailing lines in the end of the file crash the last sequence
                    if keep_first_sequence and seq == 1:
                        fid_out.write(ll)
                        continue
                    if DO_keep_sequence:
                        d_input_fasta_file[gid]['sequence'] += ll

            for gid in d_input_fasta_file:
                header = d_input_fasta_file[gid]['header']
                sequence = d_input_fasta_file[gid]['sequence']
                fid_out.write("{}{}".format(header, sequence))

    fid_out.close()
    fid_in.close()


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-i',
        '--input',
        type=str,
        required=True,
        help='Input tabulation separated file'
    )
    parser.add_argument(
        '-o',
        '--output',
        type=str,
        required=False,
        default=None,
        help='Output tabulation separated file.'
    )
    parser.add_argument(
        '-q',
        '--qid',
        default="100.",
        help='% Identity threshold with respect to query below which homologs will not be kept (range 0%-100%)'
    )
    parser.add_argument(
        '-c',
        '--cov',
        default="100.",
        help='% Coverage threshold of the query below which homologs will not be kept (range 0%-100%)'
    )
    parser.add_argument(
        '-a',
        '--alignment_input',
        default=None,
        help='Filename of the alignment which should be filtered using tsv file and the combination of qid and cov'
    )
    parser.add_argument(
        '-f',
        '--filtered_output_alignment',
        default=None,
        help='Filename of the output alignment generated after sorting/filtering'
    )

    options = parser.parse_args()
    print("Filtering the alignments using a %id threshold with the query of", options.qid)
    print("Filtering the alignments using a %coverage threshold with the query of", options.cov)

    if float(options.qid) + float(options.cov) < 200:
        if options.alignment_input:
            return_a_list=True
        else:
            return_a_list = False
        print("Retrieving the list of seq ids respecting the thresholds")
        list_gid = filter_tsv_gidlist_using_qid_cov(options.input, output_tsv=options.output, qid_threshold=float(options.qid), cov_threshold=float(options.cov), return_gid_list=return_a_list)
        print("List of seq ids respecting the thresholds retrieved")
        if options.alignment_input and list_gid:
            # Potential problem of this protocol in case a gid is present multiple times
            # The alignment file is supposed to contain only one instance of every gid, but not the tsv used to filter
            # With full-length sequences, no issue. More delicate in case of a3m directly out from Mmseqs
            print(f"Dumping a filtered alignment file {options.filtered_output_alignment} from the ordered sequences in {options.alignment_input}")
            dump_ali_from_gid_list_keep_aliorder(options.alignment_input, options.filtered_output_alignment, list_gid)
